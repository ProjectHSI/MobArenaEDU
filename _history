{"entries":[{"timestamp":1715926483991,"editorVersion":"1.7.28","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"rena"],[-1,"EDU"],[0,"\",\n "]],"start1":19,"start2":19,"length1":11,"length2":8}]}]},{"timestamp":1715926640228,"editorVersion":"1.7.28","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"y/xml\"><"],[1,"block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"minecraftOnChat\" x=\"225\" y=\"20\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" numargs=\"0\"></mutation><value name=\"command\"><shadow type=\"text\"><field name=\"TEXT\">run</field></shadow></value></block><"],[0,"/xml>"]],"start1":48,"start2":48,"length1":13,"length2":274}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":226,"start2":226,"length1":52,"length2":8}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1715926483990,"editorVersion":"1.7.28","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"minecraftOnChat\" x=\"225\" y=\"20\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" numargs=\"0\"></mutation><value name=\"command\"><shadow type=\"text\"><field name=\"TEXT\">run</field></shadow></value></block></xml>","main.ts":"/*\n  * MobArena\n  * By: [Project HSI]\n  * Description: Mob Arena Game.\n  Base Mob Arena Game\n*/\n\n// remove when finished\n//throw \"not running.\"\n\n/* Global Configuration */\nconst projectName = \"mob_arena\"\n\n/* JS Engine */\nplayer.say(\"Loading HSI JS Engine...\")\n\nnamespace js {\n    export function error(message: string) {\n        clogger.log([\"js\", \"error\"], clogger.levels.ERROR, \"Error!\")\n        clogger.log([\"js\", \"error\"], clogger.levels.ERROR, `${message}`)\n        throw error\n    }\n\n    export function assert(condition: boolean, message: string) {\n        if (!condition) error(message);\n    }\n\n    export function assertX(condition: boolean, func: Function) {\n        if (!condition) func();\n    }\n\n    export namespace array {\n        export function append(array: any[], element: any): any[] {\n            array[array.length] = element\n            return array\n        }\n\n        export function prepend(array: any[], element: any): any[] {\n            for (let i = array.length; i > 0; i--) {\n                array[i] = array[i - 1]\n            }\n            array[0] = element\n            return array\n        }\n    }\n\n    function randomInteger(min: number, max: number) {\n        // from MDN\n        min = Math.ceil(min)\n        max = Math.floor(max)\n        return Math.floor(Math.random() * (max - min + 1) + min)\n    }\n\n    export function random(min: number, max: number, decimals: number) {\n        const decimalsMultiplier = Math.pow(10, decimals)\n        return randomInteger(min * decimalsMultiplier, max * decimalsMultiplier)\n    }\n}\n\nplayer.say(\"HSI JS Engine loaded!\")\n\n/* MC Engine */\nplayer.say(\"Loading HSI MC Engine...\")\n\nnamespace mc {\n    export interface Effect {\n        spell: string,\n        amount: number,\n        duration: number\n    }\n\n    export interface Enchantment {\n        spell: string,\n        level: number\n    }\n\n    export interface UniversalItem {\n        item: string,\n        amount: number,\n        enchantments?: Enchantment[]\n    }\n\n    export interface UniversalMob {\n        mob: string,\n        amount: number\n    }\n\n    export const Colour = {\n        Black: \"§0\",\n        DarkBlue: \"§1\",\n        DarkGreen: \"§2\",\n        DarkAqua: \"§3\",\n        DarkRed: \"§4\",\n        DarkPurple: \"§5\",\n        Gold: \"§6\",\n        Grey: \"§7\",\n        DarkGrey: \"§8\",\n        Blue: \"§9\",\n        Green: \"§a\",\n        Aqua: \"§b\",\n        Red: \"§c\",\n        LightPurple: \"§d\",\n        Yellow: \"§e\",\n        White: \"§f\",\n        MineCoinGoldYellow: \"§g\",\n        MaterialQuartz: \"§h\",\n        MaterialIron: \"§i\",\n        MaterialNetherite: \"§j\",\n        MaterialRedstone: \"§m\",\n        MaterialCopper: \"§n\",\n        MaterialGold: \"§p\",\n        MaterialEmerald: \"§q\",\n        MaterialDiamond: \"§s\",\n        MaterialLapis: \"§t\",\n        MaterialAmethyst: \"§u\"\n    }\n\n    export const Style = {\n        Obfuscated: \"§k\",\n        Bold: \"§l\",\n        Italic: \"§o\",\n        Reset: \"§r\"\n    }\n\n    export function registerCommand(command: string, handler: (arguments: string[]) => void) {\n        // define some variables here\n        // so we don't need to recompute them\n        const registerCommand = `.hsi_mc.${projectName}.agent.${command}`\n        const commandLength = `${registerCommand} `.length\n\n        player.onChatCommand(registerCommand, [ChatArgument.string], (args: player.ChatCommandArguments) => {\n            let message = args.string\n            if (message == undefined) {\n                return\n            }\n            message = message.substr(0, commandLength)\n            let arguments = message.split(\".\")\n            handler(arguments)\n        })\n    }\n\n    export function giveItemTS(targetSelector: TargetSelector, item: mc.UniversalItem) {\n        if (item.item == \"shield\") {\n            player.execute(`/replaceitem entity ${targetSelector} slot.weapon.offhand 0 ${item.item}`)\n        } else if (item.item.includes(\"helmet\")) {\n            player.execute(`/replaceitem entity ${targetSelector} slot.armor.head 0 ${item.item}`)\n        } else if (item.item.includes(\"chestplate\")) {\n            player.execute(`/replaceitem entity ${targetSelector} slot.armor.chest 0 ${item.item}`)\n        } else if (item.item.includes(\"leggings\")) {\n            player.execute(`/replaceitem entity ${targetSelector} slot.armor.legs 0 ${item.item}`)\n        } else if (item.item.includes(\"boot\")) {\n            player.execute(`/replaceitem entity ${targetSelector} slot.armor.feet 0 ${item.item}`)\n        } else {\n            if (item.enchantments == undefined) {\n                player.execute(`/give ${targetSelector} ${item.item} ${item.amount}`)\n            } else {\n                player.execute(`/replaceitem entity ${targetSelector} slot.weapon.mainhand 0 ${item.item}`)\n                item.enchantments.forEach((value) => {\n                    player.execute(`/enchant ${targetSelector} ${value.spell} ${value.level}`)\n                })\n            }\n        }\n    }\n\n    export function giveItem(players: string[], item: mc.UniversalItem) {\n        players.forEach((value) => {\n            giveItemTS(mobs.playerByName(value), item)\n        })\n    }\n\n    export function clearInvTS(targetSelector: TargetSelector) {\n        player.execute(`clear ${targetSelector}`)\n    }\n\n    export function clearInv(players: string[]) {\n        players.forEach((value) => {\n            clearInvTS(mobs.playerByName(value))\n        })\n    }\n\n    export function titleTS(targetSelector: TargetSelector, title: string, subtitle: string) {\n        player.execute(`title ${targetSelector} title ${title}`)\n        player.execute(`title ${targetSelector} subtitle ${subtitle}`)\n    }\n\n    export function title(players: string[], title: string, subtitle: string) {\n        players.forEach((value) => {\n            titleTS(mobs.playerByName(value), title, subtitle)\n        })\n    }\n\n    export function actionBarTS(targetSelector: TargetSelector, text: string) {\n        player.execute(`title ${targetSelector} actionbar ${text}`)\n    }\n\n    export function actionBar(players: string[], text: string) {\n        players.forEach((value) => {\n            actionBarTS(mobs.playerByName(value), text)\n        })\n    }\n\n    export function setGameRule(gameRule: string, newValue: boolean | number) {\n        player.execute(`gamerule ${gameRule} ${newValue}`)\n    }\n\n    export function tpTStoTS(sourceTargetSelector: TargetSelector, targetTargetSelector: TargetSelector) {\n        // check if it's a single targetSelector for targetTargetSelector\n        js.assert(mobs.queryTarget(targetTargetSelector).length == 1, \"Invalid TargetSelector for targetTargetSelector.\")\n        player.execute(`tp ${sourceTargetSelector} ${targetTargetSelector}`)\n    }\n\n    export function tpTStoPos(sourceTargetSelector: TargetSelector, targetPosition: Position) {\n        // check if it's a single targetSelector for targetTargetSelector\n        player.execute(`tp ${sourceTargetSelector} ${targetPosition.getValue(Axis.X)} ${targetPosition.getValue(Axis.Y)} ${targetPosition.getValue(Axis.Z)}`)\n    }\n\n    export function tpPlayerToPlayer(sourcePlayer: string, targetPlayer: string) {\n        tpTStoTS(mobs.playerByName(sourcePlayer), mobs.playerByName(targetPlayer))\n    }\n\n    export function tpPlayerToPos(sourcePlayer: string, targetPosition: Position) {\n        tpTStoPos(mobs.playerByName(sourcePlayer), targetPosition)\n    }\n\n    export function applyEffectToTS(targetSelector: TargetSelector, effect: Effect, hideParticles: boolean) {\n        player.execute(`effect ${targetSelector} ${effect.spell} ${effect.duration} ${effect.amount} ${hideParticles}`)\n    }\n\n    export function applyEffectToPlayer(player: string, effect: Effect, hideParticles: boolean) {\n        applyEffectToTS(mobs.playerByName(player), effect, hideParticles)\n    }\n\n    export function summonMob(mob: string, position: Position) {\n        player.execute(`summon ${mob} ${position.getValue(Axis.X)} ${position.getValue(Axis.Y)} ${position.getValue(Axis.Z)}`)\n    }\n}\n\nplayer.say(\"HSI MC Engine loaded!\")\n\n/* Logging Engine */\nplayer.say(\"Loading CLogger...\")\n\nnamespace clogger {\n    enum LoggingBehaviour {\n        SAY,\n        WHISPER,\n        SLIENT\n    }\n\n    interface Level {\n        lvlString: string,\n        colour: string, // Treat as MC.Colour since string enums (in MakeCode) are weird.\n        verbose: boolean\n    }\n\n    export const levels: { [index: string]: Level } = {\n        INFO: {\n            lvlString: \"INFO\",\n            colour: mc.Colour.White,\n            verbose: false\n        },\n        WARN: {\n            lvlString: \"WARN\",\n            colour: mc.Colour.MineCoinGoldYellow,\n            verbose: false\n        },\n        ERROR: {\n            lvlString: \"ERROR\",\n            colour: mc.Colour.Red,\n            verbose: false\n        },\n        VERBOSE: {\n            lvlString: \"VERB\",\n            colour: mc.Colour.LightPurple,\n            verbose: true\n        },\n        DEBUG: {\n            lvlString: \"DEBUG\",\n            colour: mc.Colour.Green,\n            verbose: true\n        }\n    }\n\n    const loggingBehaviour: { [index: string]: LoggingBehaviour } = {\n        nonVerbose: LoggingBehaviour.SAY,\n        //verbose: LoggingBehaviour.WHISPER\n        verbose: LoggingBehaviour.SLIENT\n    }\n\n    function callAgentChatFunctionForLoggingBehaviour(content: string, loggingBehaviour: LoggingBehaviour): void {\n        if (loggingBehaviour == LoggingBehaviour.SAY) {\n            player.say(content)\n        } else if (loggingBehaviour == LoggingBehaviour.WHISPER) {\n            player.tell(mobs.playerByName(\"BIRKBECK_MCKAY_O\"), content)\n        }\n    }\n\n    function getLoggingBehaviourFromLevel(level: Level): LoggingBehaviour {\n        if (level.verbose) {\n            return loggingBehaviour.verbose\n        } else {\n            return loggingBehaviour.nonVerbose\n        }\n    }\n\n    export function log(source: string[], level: Level, content: string) {\n        source = js.array.prepend(source, projectName)\n        // we put the reset style here so that it doesn't do italics if loggingBehaviour is set to WHISPER\n        let parsedContent = `${mc.Style.Reset}${mc.Colour.LightPurple}${source.join(\"::\")} ${level.colour}(${level.lvlString}) : ${content}`\n        callAgentChatFunctionForLoggingBehaviour(parsedContent, getLoggingBehaviourFromLevel(level))\n    }\n}\n\nplayer.say(\"CLogger loaded! Handing over logging to CLogger.\")\nclogger.log([\"init\", \"clogger\"], clogger.levels.INFO, \"Loaded CLogger!\")\n\n/* Config */\n\nclogger.log([\"init\", \"game\", \"config\"], clogger.levels.VERBOSE, \"Initalizing configuration...\")\n\n// Players\nclogger.log([\"init\", \"game\", \"config\"], clogger.levels.VERBOSE, \"Loading players...\")\nlet players: string[] = [\n    \"BIRKBECK_MCKAY_O\"\n]\n\nclogger.log([\"init\", \"game\", \"config\"], clogger.levels.VERBOSE, \"Players loaded. Validating entries.\")\n\n/*\nmc.registerCommand(\"registerPlayer\", (arguments: string[]) => {\n    let doCommandExecute = true;\n\n    clogger.log([\"concommand\", \"register_player\"], clogger.levels.INFO, \"Player: \" + arguments[0])\n    \n    if (arguments[0] == undefined || arguments[0] == \"\") {\n        clogger.log([\"concommand\", \"register_player\"], clogger.levels.ERROR, `The player name isn't specified.`)\n        doCommandExecute = false\n    } else if (mobs.queryTarget(mobs.playerByName(arguments[0]))[0] == undefined) {\n        clogger.log([\"concommand\", \"register_player\"], clogger.levels.ERROR, `The player specified isn't valid.`)\n    }\n\n    clogger.log([\"concommand\", \"register_player\"], clogger.levels.INFO, \"Registered\")\n})\n*/\n\nclogger.log([\"init\", \"game\", \"config\"], clogger.levels.VERBOSE, \"Loading arena config...\")\ninterface WorldConfig {\n    time: number,\n    weather: Weather\n}\n\ninterface FillPos {\n    fromPos: Position,\n    toPos: Position\n}\n\ninterface Arena {\n    spawnPoints: {\n        arena: FillPos,\n        [index: string]: FillPos\n    },\n    safeZone: FillPos\n    worldConfig: WorldConfig\n}\n\nconst arenaConfig: Arena = {\n    spawnPoints: {\n        arena: {\n            fromPos: world(496, 71, -522),\n            toPos: world(492, 71, -501)\n        },\n        tower: {\n            fromPos: world(490, 75, -507),\n            toPos: world(486, -75, -510)\n        }\n    },\n    safeZone: {\n        fromPos: world(484, 69, -532),\n        toPos: world(504, 79, -499)\n    },\n    worldConfig: {\n        time: 282000,\n        weather: Weather.Clear\n    }\n}\n\ninterface MobSpawnEntry {\n    mob: string,\n    amount: number\n    round: number,\n    seconds: number,\n    spawnType: string\n}\n\nconst mobsSpawnEntryList: MobSpawnEntry[] = [\n    {\n        mob: \"zombie\",\n        amount: 2,\n        round: 1,\n        seconds: 0,\n        spawnType: \"arena\"\n    },\n    {\n        mob: \"creeper\",\n        amount: 1,\n        round: 5,\n        seconds: 0,\n        spawnType: \"arena\"\n    },\n    {\n        mob: \"skeleton\",\n        amount: 1,\n        round: 8,\n        seconds: 0,\n        spawnType: \"tower\"\n    },\n    {\n        mob: \"skeleton\",\n        amount: 2,\n        round: 15,\n        seconds: 0,\n        spawnType: \"arena\"\n    },\n    {\n        mob: \"blaze\",\n        amount: 2,\n        round: 15,\n        seconds: 0,\n        spawnType: \"arena\"\n    },\n    {\n        mob: \"blaze\",\n        amount: 2,\n        round: 15,\n        seconds: 0,\n        spawnType: \"tower\"\n    }\n]\n\ntype GameruleTable = { [index: string]: boolean | number }\n\nconst gamerules: GameruleTable = {\n    doDaylightCycle: false,\n    doMobSpawning: false,\n    mobGriefing: false,\n    doWeatherCycle: false,\n    doMobLoot: false,\n    pvp: false\n}\n\nconst enum GameType {\n    ROUND_BASED,\n    ENDLESS\n}\n\nconst items: mc.UniversalItem[] = [\n    {\n        item: \"diamond_sword\",\n        amount: 1,\n        enchantments: []\n    },\n    {\n        item: \"shield\",\n        amount: 1,\n        enchantments: []\n    },\n    {\n        item: \"bow\",\n        amount: 1\n    },\n    {\n        item: \"arrow\",\n        amount: 64\n    },\n    {\n        item: \"iron_helmet\",\n        amount: 1\n    },\n    {\n        item: \"iron_chestplate\",\n        amount: 1\n    }, {\n        item: \"iron_leggings\",\n        amount: 1\n    },\n    {\n        item: \"iron_boots\",\n        amount: 1\n    }\n]\n\nconst gameType: GameType = GameType.ROUND_BASED\n\nclogger.log([\"init\", \"game\", \"config\"], clogger.levels.VERBOSE, \"Done.\")\n\n// Game\n\nclogger.log([\"init\", \"game\", \"code\"], clogger.levels.VERBOSE, \"Loading code.\")\nlet playersInTheGame: string[]\nlet mobsInCurrentArena = 0\nlet maxMobsInCurrentArena = 0\n\nlet previousMobCount: { [index: string]: number }\n\nlet currentSeconds = 0\nlet currentRound = 1\nlet continueGame = true\n\nlet registrationEnabled = false\n\nfunction getInbetweenPosition(posFrom: Position, posTo: Position) {\n    let minX = Math.min(posFrom.getValue(Axis.X), posTo.getValue(Axis.X))\n    let maxX = Math.max(posFrom.getValue(Axis.X), posTo.getValue(Axis.X))\n    clogger.log([\"get_inbetween_position\"], clogger.levels.DEBUG, `Min X: ${minX}.`)\n    clogger.log([\"get_inbetween_position\"], clogger.levels.DEBUG, `Max X: ${maxX}.`)\n    let minY = Math.min(posFrom.getValue(Axis.Y), posTo.getValue(Axis.Y))\n    let maxY = Math.max(posFrom.getValue(Axis.Y), posTo.getValue(Axis.Y))\n    clogger.log([\"get_inbetween_position\"], clogger.levels.DEBUG, `Min Y: ${minY}.`)\n    clogger.log([\"get_inbetween_position\"], clogger.levels.DEBUG, `Max Y: ${maxY}.`)\n    let minZ = Math.min(posFrom.getValue(Axis.Z), posTo.getValue(Axis.Z))\n    let maxZ = Math.max(posFrom.getValue(Axis.Z), posTo.getValue(Axis.Z))\n    clogger.log([\"get_inbetween_position\"], clogger.levels.DEBUG, `Min Z: ${minZ}.`)\n    clogger.log([\"get_inbetween_position\"], clogger.levels.DEBUG, `Max Z: ${maxZ}.`)\n\n    let randomX = js.random(minX, maxX, 0)\n    let randomY = js.random(minY, maxY, 0)\n    let randomZ = js.random(minZ, maxZ, 0)\n\n    clogger.log([\"get_inbetween_position\"], clogger.levels.DEBUG, `Random X: ${randomX}.`)\n    clogger.log([\"get_inbetween_position\"], clogger.levels.DEBUG, `Random Y: ${randomY}.`)\n    clogger.log([\"get_inbetween_position\"], clogger.levels.DEBUG, `Random Z: ${randomZ}.`)\n\n    return world(randomX, randomY, randomZ)\n}\n\nfunction setupWorld() {\n    //clogger.log([\"game\", \"game_rules\"], clogger.levels.WARN, \"The following GameRules will be modified.\")\n    //Object.keys(gamerules).forEach((value) => {\n    //    clogger.log([\"game\", \"game_rules\"], clogger.levels.WARN, `${value}: ${gamerules[value]}`)\n    //    mc.setGameRule(value, gamerules[value])\n    //})\n    //clogger.log([\"game\", \"game_rules\"], clogger.levels.WARN, \"It is not recommended to reverse these changes until the end of the game.\")\n\n    //player.execute(`time set ${arenaConfig.worldConfig.time}`)\n    //gameplay.setWeather(arenaConfig.worldConfig.weather)\n}\n\nfunction clearMobs(mobsSpawnEntry: MobSpawnEntry[]) {\n    clogger.log([`clear_mobs`], clogger.levels.DEBUG, `Clearing mobs!`)\n    mobsSpawnEntry.forEach((value) => {\n        clogger.log([`clear_mobs`], clogger.levels.DEBUG, `Clearing existing mobs of type ${value.mob}`)\n        // clear up stuff for countMobs\n        player.execute(`kill @e[type=${value.mob}]`)\n    })\n}\n\nfunction spawnMobs(mobsSpawnEntry: MobSpawnEntry[]) {\n    clogger.log([`spawn_mobs`], clogger.levels.DEBUG, `Spawning mobs!`)\n    clearMobs(mobsSpawnEntry)\n    mobsSpawnEntry.forEach((value) => {\n        //loops.runInBackground(() => {\n            clogger.log([`spawn_mobs`], clogger.levels.DEBUG, `Testing should spawn.`)\n\n            let shouldSpawn: boolean\n\n            if (gameType == GameType.ROUND_BASED) {\n                shouldSpawn = value.round <= currentRound\n            } else {\n                shouldSpawn = value.seconds <= currentSeconds\n            }\n\n            clogger.log([`spawn_mobs`], clogger.levels.DEBUG, `Tested should spawn.`)\n\n            if (shouldSpawn) {\n                clogger.log([`spawn_mobs`], clogger.levels.DEBUG, `Should spawn!`)\n\n                let fillPosFrom = arenaConfig.spawnPoints[value.spawnType].fromPos\n                let fillPosTo = arenaConfig.spawnPoints[value.spawnType].toPos\n\n                clogger.log([`spawn_mobs`], clogger.levels.DEBUG, `fillPosFrom and fillPosTo filled out.`)\n\n                let effectiveMultiplier: number\n\n                if (gameType == GameType.ROUND_BASED) {\n                    effectiveMultiplier = currentRound - value.round + 1\n                } else {\n                    effectiveMultiplier = currentSeconds - value.seconds + 1\n                }\n\n                clogger.log([`spawn_mobs`], clogger.levels.DEBUG, `Got multiplier.`)\n\n                for (let i = 0; i < value.amount * effectiveMultiplier; i++) {\n                    clogger.log([`spawn_mobs`], clogger.levels.DEBUG, `Summoning.`)\n                    mc.summonMob(value.mob, getInbetweenPosition(fillPosFrom, fillPosTo));\n                }\n            }\n        //})\n    })\n}\n\nfunction teleportPlayers(players: string[]) {\n    players.forEach((value) => {\n        let pos = getInbetweenPosition(arenaConfig.spawnPoints.arena.fromPos, arenaConfig.spawnPoints.arena.toPos)\n        mc.tpPlayerToPos(value, pos)\n    })\n}\n\nfunction countMobs(mobList: string[]) {\n    let ret: number = 0\n\n    mobList.forEach((value) => {\n        let ts = mobs.parseSelector(`@e[type=${value}]`)\n        ret += mobs.queryTarget(ts).length\n    })\n\n    return ret\n}\n\nfunction announceMobs(current: number, max: number) {\n    mc.actionBar(players, `${mc.Colour.White}Round ${mc.Colour.MineCoinGoldYellow}${currentRound}\\n${mc.Colour.Red}${current} ${mc.Colour.White}/ ${mc.Colour.MineCoinGoldYellow}${max}`)\n}\n\nfunction positionInFillPos(checkPosition: Position, fillPos: FillPos) {\n    let posFrom = fillPos.fromPos\n    let posTo = fillPos.toPos\n\n    let minX = Math.min(posFrom.getValue(Axis.X), posTo.getValue(Axis.X))\n    let maxX = Math.max(posFrom.getValue(Axis.X), posTo.getValue(Axis.X))\n    clogger.log([\"position_in_fill_pos\"], clogger.levels.DEBUG, `Min X: ${minX}.`)\n    clogger.log([\"position_in_fill_pos\"], clogger.levels.DEBUG, `Max X: ${maxX}.`)\n    let minY = Math.min(posFrom.getValue(Axis.Y), posTo.getValue(Axis.Y))\n    let maxY = Math.max(posFrom.getValue(Axis.Y), posTo.getValue(Axis.Y))\n    clogger.log([\"position_in_fill_pos\"], clogger.levels.DEBUG, `Min Y: ${minY}.`)\n    clogger.log([\"position_in_fill_pos\"], clogger.levels.DEBUG, `Max Y: ${maxY}.`)\n    let minZ = Math.min(posFrom.getValue(Axis.Z), posTo.getValue(Axis.Z))\n    let maxZ = Math.max(posFrom.getValue(Axis.Z), posTo.getValue(Axis.Z))\n    clogger.log([\"position_in_fill_pos\"], clogger.levels.DEBUG, `Min Z: ${minZ}.`)\n    clogger.log([\"position_in_fill_pos\"], clogger.levels.DEBUG, `Max Z: ${maxZ}.`)\n\n    let x = Math.floor(checkPosition.getValue(Axis.X))\n    let y = Math.floor(checkPosition.getValue(Axis.Y))\n    let z = Math.floor(checkPosition.getValue(Axis.Z))\n\n    clogger.log([\"position_in_fill_pos\"], clogger.levels.DEBUG, `X: ${x}.`)\n    clogger.log([\"position_in_fill_pos\"], clogger.levels.DEBUG, `Y: ${y}.`)\n    clogger.log([\"position_in_fill_pos\"], clogger.levels.DEBUG, `Z: ${z}.`)\n\n\n    let xSubcondition1 = x >= minX\n    let xSubcondition2 = x <= maxX\n    let xCondition = (xSubcondition1 && xSubcondition2)\n    clogger.log([\"position_in_fill_pos\"], clogger.levels.DEBUG, `X S1: ${xSubcondition1}.`)\n    clogger.log([\"position_in_fill_pos\"], clogger.levels.DEBUG, `X S2: ${xSubcondition2}.`)\n    clogger.log([\"position_in_fill_pos\"], clogger.levels.DEBUG, `X C: ${xCondition}.`)\n\n    let ySubcondition1 = y >= minY\n    let ySubcondition2 = y <= maxY\n    let yCondition = (ySubcondition1 && ySubcondition2)\n    clogger.log([\"position_in_fill_pos\"], clogger.levels.DEBUG, `Y S1: ${ySubcondition1}.`)\n    clogger.log([\"position_in_fill_pos\"], clogger.levels.DEBUG, `Y S2: ${ySubcondition2}.`)\n    clogger.log([\"position_in_fill_pos\"], clogger.levels.DEBUG, `Y C: ${yCondition}.`)\n\n    let zSubcondition1 = z >= minZ\n    let zSubcondition2 = z <= maxZ\n    let zCondition = (zSubcondition1 && zSubcondition2)\n    clogger.log([\"position_in_fill_pos\"], clogger.levels.DEBUG, `Z S1: ${zSubcondition1}.`)\n    clogger.log([\"position_in_fill_pos\"], clogger.levels.DEBUG, `Z S2: ${zSubcondition2}.`)\n    clogger.log([\"position_in_fill_pos\"], clogger.levels.DEBUG, `Z C: ${zCondition}.`)\n\n    let superCondition = xCondition && yCondition && zCondition\n    clogger.log([\"position_in_fill_pos\"], clogger.levels.DEBUG, `S C: ${superCondition}.`)\n\n    return superCondition\n}\n\nfunction roundManager() {\n    mc.title(players, `${mc.Colour.White}Round ${mc.Colour.MineCoinGoldYellow}${currentRound}`, \"\")\n\n    playersInTheGame.forEach((currentPlayer) => {\n        player.execute(`clear ${currentPlayer}`)\n    })\n\n    items.forEach((value) => {\n        mc.giveItem(playersInTheGame, value)\n    })\n\n    playersInTheGame.forEach((currentPlayer) => {\n        if (true) {\n            mc.applyEffectToPlayer(currentPlayer, {\n                spell: \"strength\",\n                amount: 255,\n                duration: 30\n            }, false)\n            mc.applyEffectToPlayer(currentPlayer, {\n                spell: \"regeneration\",\n                amount: 255,\n                duration: 30\n            }, false)\n            mc.applyEffectToPlayer(currentPlayer, {\n                spell: \"regeneration\",\n                amount: 255,\n                duration: 30\n            }, false)\n            mc.applyEffectToPlayer(currentPlayer, {\n                spell: \"speed\",\n                amount: 5,\n                duration: 30\n            }, false)\n            mc.applyEffectToPlayer(currentPlayer, {\n                spell: \"resistance\",\n                amount: 255,\n                duration: 30\n            }, false)\n            mc.applyEffectToPlayer(currentPlayer, {\n                spell: \"health_boost\",\n                amount: 10,\n                duration: 30\n            }, false)\n        }\n        mc.applyEffectToPlayer(currentPlayer, {\n            spell: \"instant_health\",\n            amount: 255,\n            duration: 5\n        }, true)\n        mc.applyEffectToPlayer(currentPlayer, {\n            spell: \"saturation\",\n            amount: 255,\n            duration: 5\n        }, true)\n\n        player.execute(`gamemode survival ${currentPlayer}`)\n    })\n\n    let mobsToBeCounted: string[] = []\n\n    mobsSpawnEntryList.forEach((value) => {\n        js.array.append(mobsToBeCounted, value.mob)\n    })\n\n    clogger.log([`round_manager`, `mobs`], clogger.levels.DEBUG, `Spawning mobs.`)\n\n    spawnMobs(mobsSpawnEntryList)\n\n    clogger.log([`round_manager`, `mobs`], clogger.levels.DEBUG, `Done.`)\n\n    maxMobsInCurrentArena = countMobs(mobsToBeCounted)\n    mobsInCurrentArena = countMobs(mobsToBeCounted)\n\n    clogger.log([`round_manager`, `mobs`], clogger.levels.DEBUG, `Mobs: ${mobsInCurrentArena}`)\n    clogger.log([`round_manager`, `mobs`], clogger.levels.DEBUG, `Max Mobs: ${maxMobsInCurrentArena}`)\n\n    while (mobsInCurrentArena != 0 && continueGame) {\n        announceMobs(countMobs(mobsToBeCounted), maxMobsInCurrentArena)\n\n        playersInTheGame.forEach((currentPlayer) => {\n            if (currentPlayer == undefined) {\n                clogger.log([`round_manager`, `player_checks`], clogger.levels.WARN, `Crash averted!`)\n                return\n            }\n            clogger.log([`round_manager`, `player_checks`, `${currentPlayer}`], clogger.levels.DEBUG, `Running on ${currentPlayer}`)\n            let ts = mobs.playerByName(currentPlayer)\n            let query = mobs.queryTarget(ts)[0]\n            let position = world(query.x, query.y, query.z)\n\n            clogger.log([`round_manager`, `player_checks`, `${currentPlayer}`], clogger.levels.DEBUG, `Got basic information.`)\n\n            if (!positionInFillPos(position, arenaConfig.safeZone)) {\n                clogger.log([`round_manager`, `player_checks`, `${currentPlayer}`], clogger.levels.DEBUG, `Oops, the player's dead!`)\n                clogger.log([`round_manager`, `player_checks`, `${currentPlayer}`], clogger.levels.DEBUG, `Removing player.`)\n                playersInTheGame.removeElement(currentPlayer)\n                clogger.log([`round_manager`, `player_checks`, `${currentPlayer}`], clogger.levels.DEBUG, `Player's removed. Announcing.`)\n                clogger.log([\"game\"], clogger.levels.INFO, `${currentPlayer} died!`)\n\n                clogger.log([`round_manager`, `player_checks`, `${currentPlayer}`], clogger.levels.DEBUG, `Checking whether to continue the game.`)\n                if (playersInTheGame.length == 1 || playersInTheGame.length == 0) {\n                    clogger.log([`round_manager`, `player_checks`, `${currentPlayer}`], clogger.levels.DEBUG, `GAME OVER`)\n                    continueGame = false\n                }\n            }\n        })\n\n        mobsInCurrentArena = countMobs(mobsToBeCounted)\n    }\n}\n\nfunction startGame(arguments: string[]) {\n    clogger.log([\"game\"], clogger.levels.VERBOSE, \"Initalizing game, please wait.\")\n\n    let continueWithInitalization = true\n\n    if (players.length == 0) {\n        clogger.log([\"game\", \"config_validator\"], clogger.levels.WARN, \"No players have been registered, perhaps register some players?\")\n        continueWithInitalization = false\n    }\n\n    players.forEach(function (v, _) {\n        clogger.log([\"game\", \"config_validator\", v], clogger.levels.VERBOSE, `Player: ${v}.`)\n        if (mobs.queryTarget(mobs.playerByName(v))[0] == undefined) {\n            clogger.log([\"game\", \"config_validator\", v], clogger.levels.WARN, `Player ${v} isn't valid!`)\n            continueWithInitalization = false\n        } else {\n            clogger.log([\"game\", \"config_validator\", v], clogger.levels.VERBOSE, `Player ${v} is valid!`)\n        }\n    })\n\n    if (!continueWithInitalization) {\n        clogger.log([\"game\", \"config_validator\"], clogger.levels.ERROR, `Something happened and the game couldn't start.`)\n        clogger.log([\"game\", \"config_validator\"], clogger.levels.ERROR, `Please check the messages above and try again.`)\n        return\n    }\n\n    playersInTheGame = players\n\n    teleportPlayers(playersInTheGame)\n\n    currentSeconds = 0;\n    currentRound = 1;\n    continueGame = true;\n\n    setupWorld()\n\n    clogger.log([\"game\"], clogger.levels.INFO, \"Starting game.\")\n\n    while (continueGame) {\n        roundManager()\n        currentRound++\n    }\n\n    clogger.log([\"game\"], clogger.levels.INFO, \"Game finished!\")\n    clogger.log([\"game\"], clogger.levels.INFO, `Round: ${currentRound - 1}`)\n    clogger.log([\"game\"], clogger.levels.INFO, `Mobs: ${mobsInCurrentArena} / ${maxMobsInCurrentArena}`)\n    if (playersInTheGame.length == 1) {\n        clogger.log([\"game\"], clogger.levels.INFO, ``)\n        clogger.log([\"game\"], clogger.levels.INFO, `Winning player: ${playersInTheGame[0]}`)\n    }\n}\n\nfunction toggleRegistration(arguments: string[]) {\n    if (arguments[0] != \"true\" && arguments[0] != \"false\") {\n        clogger.log([\"concommand\", \"toggle_registration\"], clogger.levels.ERROR, \"Argument 1 must be a boolean (true/false).\")\n        return\n    }\n\n    if (arguments[0] == \"true\") {\n        registrationEnabled = true\n        clogger.log([\"concommand\", \"toggle_registration\"], clogger.levels.INFO, \"Registration enabled!\")\n    } else if (arguments[0] == \"false\") {\n        registrationEnabled = false\n        clogger.log([\"concommand\", \"toggle_registration\"], clogger.levels.INFO, \"Registration disabled.\")\n    }\n}\n\nfunction registerPlayer(arguments: string[]) {\n    if (!registrationEnabled) {\n        clogger.log([\"concommand\", \"register_player\"], clogger.levels.ERROR, \"Registration has been disabled.\")\n        return\n    }\n\n    if (arguments[0] != \"reg\" && arguments[0] != \"dereg\") {\n        clogger.log([\"concommand\", \"register_player\"], clogger.levels.ERROR, \"Argument 1 must be either 'reg' or 'dereg'.\")\n        return\n    }\n\n    if (arguments[1] == undefined) {\n        clogger.log([\"concommand\", \"register_player\"], clogger.levels.ERROR, \"Argument 2 can not be empty.\")\n        return\n    }\n\n    if (mobs.queryTarget(mobs.playerByName(arguments[1]))[0] == undefined) {\n        clogger.log([\"concommand\", \"register_player\"], clogger.levels.ERROR, \"Argument 2 must be a valid player.\")\n        return\n    }\n\n    if (arguments[0] == \"reg\") {\n        if (players.indexOf(arguments[1]) != -1) {\n            clogger.log([\"concommand\", \"register_player\"], clogger.levels.ERROR, \"Player \" + arguments[1] + \" is already registered. Maybe you wanted to unregister a player?\")\n            return\n        }\n        clogger.log([\"concommand\", \"register_player\"], clogger.levels.INFO, \"Registered player \" + arguments[1] + \".\")\n        clogger.log([\"concommand\", \"register_player\"], clogger.levels.INFO, \"Please put your items in a chest before we start the game.\")\n        players = js.array.append(players, arguments[1])\n    } else if (arguments[0] == \"dereg\") {\n        if (players.indexOf(arguments[1]) == -1) {\n            clogger.log([\"concommand\", \"register_player\"], clogger.levels.ERROR, \"Player \" + arguments[1] + \" is already unregistered. Maybe you wanted to register a player?\")\n            return\n        }\n        clogger.log([\"concommand\", \"register_player\"], clogger.levels.INFO, \"Unregistered player \" + arguments[1] + \".\")\n        players.removeElement(arguments[1])\n    }\n}\n\n//mc.actionBar(players, `${mc.Colour.MineCoinGoldYellow}This is some cool text!${mc.Colour.Red} Or maybe not...`)\n\nclogger.log([\"init\", \"game\", \"code\"], clogger.levels.VERBOSE, \"Done.\")\n\nmc.registerCommand(`start`, startGame)\nmc.registerCommand(`toggle_reg`, toggleRegistration)\nmc.registerCommand(`reg_player`, registerPlayer)\n\nclogger.log([\"init\", \"game\", \"code\"], clogger.levels.INFO, projectName + \" is ready!\")\nclogger.log([\"init\", \"game\", \"code\"], clogger.levels.INFO, `Run commands by saying this in chat: \".hsi_mc.${projectName}.agent.{command}\".`)","README.md":"","custom.ts":"\n/**\n* Use this file to define custom functions and blocks.\n* Read more at https://minecraft.makecode.com/blocks/custom\n*/\n\nenum MyEnum {\n    //% block=\"one\"\n    One,\n    //% block=\"two\"\n    Two\n}\n\n/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\"\nnamespace custom {\n    /**\n     * TODO: describe your function here\n     * @param n describe parameter here, eg: 5\n     * @param s describe parameter here, eg: \"Hello\"\n     * @param e describe parameter here\n     */\n    //% block\n    export function foo(n: number, s: string, e: MyEnum): void {\n        // Add code here\n    }\n\n    /**\n     * TODO: describe your function here\n     * @param value describe value here, eg: 5\n     */\n    //% block\n    export function fib(value: number): number {\n        return value <= 1 ? value : fib(value -1) + fib(value - 2);\n    }\n}\n","pxt.json":"{\n    \"name\": \"MobArena\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"builder\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"custom.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v1.7.28\",\n        \"tag\": \"v1.7.28\",\n        \"commits\": \"https://github.com/microsoft/pxt-minecraft/commits/43da08b76c2f6625ff14c4dd6110a975e16396e8\",\n        \"target\": \"1.7.28\",\n        \"pxt\": \"9.2.8\"\n    },\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[]}